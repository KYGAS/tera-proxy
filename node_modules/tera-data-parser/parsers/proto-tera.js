const Proto = require('./proto'),
	{ Customize, SkillID, Vec3 } = require('../types')

const MULT_INT16_TO_RAD = 1 / 0x8000 * Math.PI,
	MULT_RAD_TO_INT16 = 1 / Math.PI * 0x8000

const SKILL_ID_32 = {
	read(data) {
		const raw = data.buf.readUInt32LE(data.pos),
			type = raw >> 26 & 0xf,
			npc = Boolean(raw & 0x40000000)

		data.pos += 8

		return new SkillID({
			id: raw & (npc ? 0xffff : 0x3ffffff),
			huntingZoneId: npc ? (raw >> 16) & 0x3ff : 0,
			type,
			npc,
			reserved: raw >> 31
		})
	},
	write(data, val) {
		if(val == null) data.buf.fill(0, data.pos, data.pos += 8)
		else {
			if(typeof val === 'number') val = { type: 1, id: val }

			let raw = (Number(val.id) || 0) & (val.npc ? 0xffff : 0x3ffffff)
			if(val.npc) raw |= (val.huntingZoneId & 0x3ff) << 16
			raw |= (val.type & 0xf) << 26
			raw |= (val.npc & 1) << 30
			raw |= (val.reserved & 1) << 31

			data.pos = data.buf.writeUInt32LE(raw, data.pos)
		}
	},
	length: 4
}

const SKILL_ID_64 = {
	read(data) {
		const raw = data.buf.readBigUInt64LE(data.pos),
			type = Number(raw >> 28n & 0xfn),
			npc = Boolean(raw & 0x0100000000n)

		data.pos += 8

		return new SkillID({
			id: Number(raw & (npc ? 0xffffn : 0xfffffffn)),
			huntingZoneId: npc ? Number(raw >> 16n & 0xfffn) : 0,
			type,
			npc,
			reserved: Number(raw >> 33n)
		})
	},
	write(data, val) {
		if(val == null) data.buf.fill(0, data.pos, data.pos += 8)
		else {
			if(typeof val === 'number') val = { type: 1, id: val }

			let raw = BigInt((Number(val.id) || 0) & (val.npc ? 0xffff : 0xfffffff))
			if(val.npc) raw |= BigInt(val.huntingZoneId & 0xfff) << 16n
			raw |= BigInt(val.type & 0xf) << 28n
			raw |= BigInt(val.npc & 1) << 32n
			raw |= BigInt(val.reserved & 1) << 33n

			data.pos = data.buf.writeBigUInt64LE(raw, data.pos)
		}
	},
	length: 8
}

class ProtoTera extends Proto {
	constructor(gameVersion) {
		super(gameVersion)

		Object.assign(this, {
			bool: {
				compileRead(compile, id) { compile.str += `${id} = !!data.buf[data.pos++]\n` },
				compileWrite(compile, id) { compile.str += `data.buf[data.pos++] = ${id} ? 1 : 0\n` },
				length: 1
			},
			byte: {
				compileRead(compile, id) { compile.str += `${id} = data.buf[data.pos++]\n` },
				compileWrite(compile, id) { compile.str += `data.buf[data.pos++] = ${id}\n` },
				length: 1
			},
			int16: {
				compileRead(compile, id) {
					compile.str += `${id} = data.buf.readInt16LE(data.pos)\n`
					compile.str += `data.pos += 2\n`
				},
				compileWrite(compile, id) {
					compile.str += `data.buf[data.pos] = ${id}\n`
					compile.str += `data.buf[data.pos + 1] = ${id} << 8\n`
					compile.str += `data.pos += 2\n`
				},
				length: 2
			},
			uint16: {
				compileRead(compile, id) {
					compile.str += `${id} = data.buf.readUInt16LE(data.pos)\n`
					compile.str += `data.pos += 2\n`
				},
				compileWrite(compile, id) {
					compile.str += `data.buf[data.pos] = ${id}\n`
					compile.str += `data.buf[data.pos + 1] = ${id} << 8\n`
					compile.str += `data.pos += 2\n`
				},
				length: 2
			},
			int32: {
				compileRead(compile, id) {
					compile.str += `${id} = data.buf.readInt32LE(data.pos)\n`
					compile.str += `data.pos += 4\n`
				},
				compileWrite(compile, id) {
					compile.str += `data.buf[data.pos] = ${id}\n`
					compile.str += `data.buf[data.pos + 1] = ${id} << 8\n`
					compile.str += `data.buf[data.pos + 2] = ${id} << 16\n`
					compile.str += `data.buf[data.pos + 3] = ${id} << 24\n`
					compile.str += `data.pos += 4\n`
				},
				length: 4
			},
			uint32: {
				compileRead(compile, id) {
					compile.str += `${id} = data.buf.readUInt32LE(data.pos)\n`
					compile.str += `data.pos += 4\n`
				},
				compileWrite(compile, id) {
					compile.str += `data.buf[data.pos] = ${id}\n`
					compile.str += `data.buf[data.pos + 1] = ${id} << 8\n`
					compile.str += `data.buf[data.pos + 2] = ${id} << 16\n`
					compile.str += `data.buf[data.pos + 3] = ${id} << 24\n`
					compile.str += `data.pos += 4\n`
				},
				length: 4
			},
			int64: {
				compileRead(compile, id) {
					compile.str += `${id} = data.buf.readBigInt64LE(data.pos)\n`
					compile.str += `data.pos += 8\n`
				},
				compileWrite(compile, id) {
					const temp = compile.local(), lo = compile.local(), hi = compile.local()
					compile.str += `let ${temp} = ${id}\n`
					compile.str += `if(${temp} == null) ${temp} = 0n\n`
					compile.str += `else if(typeof ${temp} !== 'bigint') ${temp} = BigInt(${temp})\n`

					compile.str += `const ${lo} = Number(${temp} & 0xffffffffn)\n`
					compile.str += `data.buf[data.pos] = ${lo}\n`
					compile.str += `data.buf[data.pos + 1] = ${lo} << 8\n`
					compile.str += `data.buf[data.pos + 2] = ${lo} << 16\n`
					compile.str += `data.buf[data.pos + 3] = ${lo} << 24\n`
					compile.str += `const ${hi} = Number(${temp} >> 32n & 0xffffffffn)\n`
					compile.str += `data.buf[data.pos + 4] = ${hi}\n`
					compile.str += `data.buf[data.pos + 5] = ${hi} << 8\n`
					compile.str += `data.buf[data.pos + 6] = ${hi} << 16\n`
					compile.str += `data.buf[data.pos + 7] = ${hi} << 24\n`
					compile.str += `data.pos += 8\n`
				},
				length: 8
			},
			uint64: {
				compileRead(compile, id) {
					compile.str += `${id} = data.buf.readBigUInt64LE(data.pos)\n`
					compile.str += `data.pos += 8\n`
				},
				compileWrite(compile, id) {
					const temp = compile.local(), lo = compile.local(), hi = compile.local()
					compile.str += `let ${temp} = ${id}\n`
					compile.str += `if(${temp} == null) ${temp} = 0n\n`
					compile.str += `else if(typeof ${temp} !== 'bigint') ${temp} = BigInt(${temp})\n`

					compile.str += `const ${lo} = Number(${temp} & 0xffffffffn)\n`
					compile.str += `data.buf[data.pos] = ${lo}\n`
					compile.str += `data.buf[data.pos + 1] = ${lo} << 8\n`
					compile.str += `data.buf[data.pos + 2] = ${lo} << 16\n`
					compile.str += `data.buf[data.pos + 3] = ${lo} << 24\n`
					compile.str += `const ${hi} = Number(${temp} >> 32n & 0xffffffffn)\n`
					compile.str += `data.buf[data.pos + 4] = ${hi}\n`
					compile.str += `data.buf[data.pos + 5] = ${hi} << 8\n`
					compile.str += `data.buf[data.pos + 6] = ${hi} << 16\n`
					compile.str += `data.buf[data.pos + 7] = ${hi} << 24\n`
					compile.str += `data.pos += 8\n`
				},
				length: 8
			},

			float: Proto.StandardType('FloatLE', 4),
			double: Proto.StandardType('DoubleLE', 8),

			vec3: {
				read(data) {
					const val = new Vec3(
						data.buf.readFloatLE(data.pos),
						data.buf.readFloatLE(data.pos + 4),
						data.buf.readFloatLE(data.pos + 8)
					)
					data.pos += 12
					return val
				},
				compileWrite(compile, id) {
					compile.str += `if(${id} == null) data.buf.fill(0, data.pos, data.pos += 12)\n`
					compile.str += `else {\n`
					compile.write(['float'], `${id}.x`)
					compile.write(['float'], `${id}.y`)
					compile.write(['float'], `${id}.z`)
					compile.str += `}\n`
				},
				length: 12
			},

			vec3fa: {
				read(data) {
					const val = new Vec3(
						data.buf.readFloatLE(data.pos) * MULT_INT16_TO_RAD,
						data.buf.readFloatLE(data.pos + 4) * MULT_INT16_TO_RAD,
						data.buf.readFloatLE(data.pos + 8) * MULT_INT16_TO_RAD
					)
					data.pos += 12
					return val
				},
				compileWrite(compile, id) {
					compile.str += `if(${id} == null) data.buf.fill(0, data.pos, data.pos += 12)\n`
					compile.str += `else {\n`
					compile.write(['float'], `Math.round(${id}.x * ${MULT_RAD_TO_INT16} % 0x10000)`)
					compile.write(['float'], `Math.round(${id}.y * ${MULT_RAD_TO_INT16} % 0x10000)`)
					compile.write(['float'], `Math.round(${id}.z * ${MULT_RAD_TO_INT16} % 0x10000)`)
					compile.str += `}\n`
				},
				length: 12
			},

			angle: {
				compileRead(compile, id) {
					compile.str += `${id} = data.buf.readInt16LE(data.pos) * ${MULT_INT16_TO_RAD}\n`
					compile.str += `data.pos += 2\n`
				},
				compileWrite(compile, id) {
					compile.str += `data.pos = data.buf.writeInt16LE(Math.round(${id} * ${MULT_RAD_TO_INT16}), data.pos)\n`
				},
				length: 2
			},

			skillid: gameVersion < 74 ? SKILL_ID_32 : SKILL_ID_64,

			customize: {
				read(data) {
					const val = new Customize(data.buf.readBigUInt64LE(data.pos))
					data.pos += 8
					return val
				},
				write(data, val) {
					if(val == null) data.buf.fill(0, data.pos, data.pos += 8)
					else {
						if(typeof val === 'bigint') val = new Customize(val)
						data.buf[data.pos++] = this.unk
						data.buf[data.pos++] = this.skinColor
						data.buf[data.pos++] = this.faceStyle
						data.buf[data.pos++] = this.faceDecal
						data.buf[data.pos++] = this.hairStyle
						data.buf[data.pos++] = this.hairColor
						data.buf[data.pos++] = this.voice
						data.buf[data.pos++] = this.tattoos
					}
				},
				length: 8
			},

			array: {
				compileRead(compile, id, subType) {
					const size = compile.local(),
						pointer = compile.local(),
						rtnPos = compile.local(),
						temp = compile.local()

					compile.read(['uint16'], `let ${size}`)
					compile.read(['uint16'], `let ${pointer}`)
					compile.str += `const ${rtnPos} = data.pos\n`
					compile.str += `${id} = []\n`

					compile.str += `for(let ${temp}; ${size}; ${size}--) {\n`
					// Sanity check
					compile.str += `if(data.pos > ${pointer}) throw Error(\`Array element pointer is backwards ($\{data.pos - 4} > $\{${pointer}})\`)\n`
					// Jump to next element
					compile.str += `data.pos = ${pointer}\n`
					// Pointer to current element (for error check)
					compile.str += `if(data.buf.readUInt16LE(data.pos) !== data.pos) throw Error(\`Invalid array element @ $\{data.pos}\`)\n`
					compile.str += `data.pos += 2\n`
					// Pointer to next element
					compile.read(['uint16'], pointer)
					// Element data
					if(subType) compile.read(subType, temp)
					compile.str += `${id}.push(${temp})\n`
					compile.str += `}\n`

					// Sanity check
					compile.str += `if(${pointer}) throw Error('Unterminated array')\n`
					compile.str += `data.pos = ${rtnPos}\n`
				},

				compileWrite(compile, id, subType) {
					compile.str += `if(!Array.isArray(${id})) ${id} = []\n`

					const ptrPos = compile.local(),
						i = compile.local()

					compile.write(['uint16'], `${id}.length`)
					compile.str += `let ${ptrPos} = data.pos\n`
					compile.write(['uint16'], '0')

					const main = compile.popState()
					compile.str += `for(let ${i} = 0; ${i} < ${id}.length; ${i}++) {\n`
					// Write current position to previous pointer
					compile.str += `data.buf.writeUInt16LE(data.pos, ${ptrPos})\n`
					// Pointer to current element (for error check)
					compile.write(['uint16'], 'data.pos')
					// Pointer to next element
					compile.str += `${ptrPos} = data.pos\n`
					compile.write(['uint16'], '0')
					// Element data
					if(subType) compile.write(subType, `${id}[${i}]`)
					compile.flushState()
					compile.str += `}\n`
					compile.pushState(main)
				},

				compileLength(compile, id, subType) {
					let str = `if(!Array.isArray(${id})) ${id} = []\n`

					const i = compile.local(),
						length = subType ? compile.length(subType, `${id}[${i}]`) : 0

					if(typeof length === 'number')
						str += `len += 4 + ${4 + length}*${id}.length\n`
					else {
						str += `len += 4 + 4*${id}.length\n`
						str += `for(let ${i} = 0; ${i} < ${id}.length; ${i}++) {\n`
						str += length
						str += `}\n`
					}

					return str
				}
			},

			string: {
				compileRead(compile, id) {
					const pointer = compile.local(),
						rtnPos = compile.local(),
						c = compile.local()

					compile.read(['uint16'], `const ${pointer}`)
					compile.str += `const ${rtnPos} = data.pos\n`

					// Sanity check
					compile.str += `if(data.pos > ${pointer}) throw Error(\`String pointer is backwards ($\{data.pos - 2} > $\{${pointer}})\`)\n`

					compile.str += `data.pos = ${pointer}\n`
					compile.str += `${id} = ''\n`
					compile.str += `for(let ${c}; ${c} = data.buf.readUInt16LE(data.pos); data.pos += 2) ${id} += String.fromCharCode(${c})\n`
					compile.str += `data.pos = ${rtnPos}\n`
				},

				compileWrite(compile, id) {
					const ptrPos = compile.local()

					compile.str += `const ${ptrPos} = data.pos\n`
					compile.str += `data.pos += 2\n`

					const main = compile.popState()
					compile.str += `data.buf.writeUInt16LE(data.pos, ${ptrPos})\n`
					compile.str += `if(!${id}) ${id} = ''\n`
					compile.str += `data.buf.fill(${id} + '\\0', data.pos, data.pos += 2 + 2*${id}.length, 'ucs2')\n`
					compile.pushState(main)
				},

				compileLength(compile, id) { return `len += 4 + 2*(${id} || '').length\n` }
			},

			bytes: {
				compileRead(compile, id) {
					const pointer = compile.local(),
						size = compile.local(),
						rtnPos = compile.local()

					compile.read(['uint16'], `const ${pointer}`)
					compile.read(['uint16'], `const ${size}`)
					compile.str += `const ${rtnPos} = data.pos\n`

					// Sanity check
					compile.str += `if(${size} && data.pos > ${pointer}) throw Error(\`Bytes pointer is backwards ($\{data.pos - 4} > $\{${pointer}})\`)\n`

					compile.str += `data.pos = ${pointer}\n`
					compile.str += `${id} = Buffer.from(data.buf.slice(data.pos, data.pos + ${size}))\n`
					compile.str += `data.pos = ${rtnPos}\n`
				},

				compileWrite(compile, id) {
					compile.str += `if(!${id}) ${id} = ''\n`

					const ptrPos = compile.local()

					compile.str += `const ${ptrPos} = data.pos\n`
					compile.str += `data.pos += 2\n`
					compile.write(['uint16'], `${id}.length`)

					const main = compile.popState()
					compile.str += `if(!${id}.length) data.buf.writeUInt16LE(0, ${ptrPos})\n`
					compile.str += `else {\n`
					compile.str += `data.buf.writeUInt16LE(data.pos, ${ptrPos})\n`
					compile.str += `${id}.copy(data.buf, data.pos)\n`
					compile.str += `data.pos += ${id}.length\n`
					compile.str += `}\n`
					compile.pushState(main)
				},

				compileLength(compile, id) { return `len += 4 + (${id} || '').length\n` }
			}
		})
	}
}

module.exports = ProtoTera