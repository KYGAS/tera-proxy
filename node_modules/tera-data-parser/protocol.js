'use strict'

const fs = require('fs'),
	path = require('path'),
	ProtoTera = require('./parsers/proto-tera'),
	enumParser = require('./parsers/enum'),
	defParser = require('./parsers/def')

const teraData = path.dirname(require.resolve('tera-data'))

// Pre-allocated object for protocol methods
const protoData = { buf: null, pos: 0 }

class TeraProtocol {
	constructor(shareRevision) {
		this.shareRevision = shareRevision

		const rev = require('tera-data/revisions')[shareRevision]
		if(!rev) throw Error(`Entry for protocol ${shareRevision} not found in tera-data/revisions.json`)

		this.parseRevision(rev)

		try {
			this.packetEnum = enumParser(path.join(teraData, `map/protocol.${this.shareRevision}.map`))
		}
		catch(e) {
			throw Error(`protocol.${this.shareRevision}.map not found`)
		}

		try {
			this.sysmsgEnum = enumParser(path.join(teraData, `map/sysmsg.${this.sysmsgVersion || this.majorPatchVersion}.map`))
		}
		catch(e) {
			throw Error(`sysmsg.${this.sysmsgVersion || this.majorPatchVersion}.map not found`)
		}

		this.proto = new ProtoTera(this.gameVersion)
		this.packets = new Map()
	}

	parseRevision(rev) {
		// (region-)majorPatchVersion(.minorPatchVersion)(/sysmsgVersion)
		const match = /^((.+?)-)?(\d+)(\.(\d+))?(\/(\d+))?$/.exec(rev)

		if(!match) throw Error(`Invalid revision "${rev}"`)

		this.region = match[2]
		this.majorPatchVersion = Number(match[3])
		this.minorPatchVersion = Number(match[5]) || 0
		this.gameVersion = this.majorPatchVersion + this.minorPatchVersion/100
		this.sysmsgVersion = match[7] ? Number(match[7]) : undefined
	}

	// def|version, buf
	parse(def, buf) {
		try {
			if(typeof def === 'number') {
				const code = buf.readUInt16LE(2),
					id = code | def << 16

				let compiled = this.packets.get(id)
				if(!compiled) {
					compiled = defParser.compile(TeraProtocol.defs.get(this.packetEnum.code.get(code)).get(def), this.proto)
					this.packets.set(id, compiled)
				}

				def = compiled
			}

			protoData.buf = buf
			protoData.pos = 4
			const out = def.read(protoData)
			protoData.buf = null
			return out
		}
		catch(e) {
			const name = this.packetEnum.code.get(code)
			require('log').error(`Error parsing ${name}:`)
			throw e
		}
	}

	// name|code, def|version, val
	write(name, def, val) {
		const code = typeof name === 'number' ? name : this.packetEnum.name.get(name)

		try {
			if(typeof def === 'number') {
				const id = code | def << 16

				let compiled = this.packets.get(id)
				if(!compiled) {
					if(name === code) name = this.packetEnum.code.get(code)

					compiled = defParser.compile(TeraProtocol.defs.get(name).get(def), this.proto)
					this.packets.set(id, compiled)
				}

				def = compiled
			}

			protoData.buf = Buffer.allocUnsafe(4 + def.length(val))
			protoData.pos = 4
			// Write header
			protoData.buf.writeUInt16LE(protoData.buf.length, 0)
			protoData.buf.writeUInt16LE(code, 2)
			// Write body
			def.write(protoData, val)
		}
		catch(e) {
			if(name === code) name = this.packetEnum.code.get(code)
			require('log').error(`Error writing ${name}:`)
			throw e
		}

		const out = protoData.buf
		protoData.buf = null
		return out
	}

	isPacketMapped(name) {

	}

	static loadDefs() {
		this.defs = new Map()

		const dir = path.join(teraData, 'protocol')
		for(let file of fs.readdirSync(dir)) {
			const match = /^(.+?)\.(\d+)\.def$/.exec(file)
			if(!match) continue

			const name = match[1],
				version = Number(match[2])

			let versions = this.defs.get(name)
			if(!versions) this.defs.set(name, versions = new Map())
			versions.set(version, defParser.parse(fs.readFileSync(path.join(dir, file), 'utf8')))
		}

		this.versionCheck = defParser.compile(this.defs.get('C_CHECK_VERSION').get(1), new ProtoTera(0))
	}

	static parseVersionCheck(buf) {
		protoData.buf = buf
		protoData.pos = 4
		const out = this.versionCheck.read(protoData)
		protoData.buf = null
		return out
	}
}

TeraProtocol.loadDefs()

module.exports = TeraProtocol